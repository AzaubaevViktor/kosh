 * Доступ к переменным окружения
 * Встроенные функции
 * (7) Каналы для файлов/процессов
 * background запуск программ
 * При ошибке крашится не все команды, а только нужнозависимые
 * (5) Корректная обработка сигналов
 * (6) CTRL-Z в фоновый режим текущую программу
 * Тесты
 * Красивая Отладка
Выдержка из заданий:
(1)
===
В этом упражнении вы должны разработать упрощенную версию командного интерпретатора системы UNIX - shell. В дальнейшем этот shell будет улучшен добавлением программных каналов и обработки сигналов. Для вас заранее написаны некоторые функции этой программы. В файле shell.c содержится скелет функции main() с комментариями, говорящими, где следует вставить ваш код. Функция main() вызывает функцию prompline() из файла promptline.c, которая читает строку из стандартного ввода. Затем main() вызывает parseline() из файла parseline.c, которая проверяет ввод на отсутствие синтаксических ошибок. Для каждой команды в строке, parseline() формирует дескриптор команды типа struct command, определенного в shell.h Существует глобальный массив таких структур, называемый cmds[] и объявленный в shell.c. Дескриптор команды состоит из двух полей. Первое поле - массив указателей, называемый cmdargs[]. Функция parseline() инициализирует этот массив указателями на строки - аргументы. Каждый аргумент завершается нулевым байтом. Во входной строке аргументы разделяются пробелами. Кроме того, parseline() помещает после последнего аргумента в списке cmdargs[] нулевой указатель. Команды могут разделяться переводом строки, точкой с запятой, амперсендом (&) или символами <, >, >> или |. Другие глобальные переменные, объявленные в shell.c определяют, должна ли команда быть запущена в основном (foreground) или фоновом (background) режиме, а также для перенаправления ввода/вывода из/в файл. Эти переменные (bkgrnd, infile, outfile и appfile) устанавливаются в функции parseline(). Если bkgrnd ненулевой, команда должна быть запущена в фоновом режиме, то есть ваш shell не должен ожидать завершения соответствующего процесса. Если infile ненулевой, он указывает на имя файла, из которого должен быть получен стандартный ввод первой команды в строке, т.е. символ <. Аналогично, если outfile ненулевой, он указывает на имя файла, куда следует перенаправить вывод последней команды в строке, т.е. символ >. Наконец, если appfile ненулевой, это имя файла, к содержимому которого следует добавить вывод последней команды в строке, т.е. символ >>. В следующих упражнениях вы будете модифицировать shell.c. Каждое последующее упражнение является улучшением предыдущего. Вы должны использовать следующую версию вызова exec(2): 
execvp(cmds[i].cmdargs[0], cmds[i].cmdargs);
ГОТОВО
(2)
===
Модифицируйте shell.c для исполнения каждой команды в массиве cmds[] как подпроцесса. Во время исполнения этого подпроцесса, ваша программа должна ждать его завершения. Если программа, заданная во входной строке, не может быть найдена, shell должен распечатать сообщение об ошибке и продолжить исполнение. Предполагается, что пользователь набирает только простые команды, т.е. только одна команда на строке, без метасимволов, перенаправления ввода/вывода, конвейеров и символа &.
ГОТОВО
(3)
===
Измените вашу программу так, чтобы позволить исполнение команд в фоновом режиме, обозначаемое символом & в конце командной строки. Программа должна выводить идентификатор фонового процесса на стандартный вывод.
Создаём форк
master
child -> child      -- ждём заверщения grandchild
         grandchild -- exec нужной команды 
ГОТОВО
(4)
===
Измените вашу программу так, чтобы позволить перенаправление ввода/вывода. Заметьте, что перенаправление ввода ("< filename") используется только с первой командой в строке, а вывода ("> filename" или ">> filename") - только с последней. 
! Тут полнейшая хрень. поток может применяться к каждой команде, и при этом надо учитывать то, что может быть поток+конвейер+appпоток. Это надо корректно обрабатывать
ГОТОВО
(5)
===
Измените исходный текст программы shell так, чтобы она не завершалась, когда вы генерируете сигнал SIGINT. Вместо этого должен завершаться процесс первого плана, а ваш shell должен -немедленно выдавать приглашение. Кроме того, предохраните команды, исполняемые в фоновом режиме, от прерывания сигналами SIGINT и SIGQUIT. (Если вы не имеете собственной версии этой программы, вы можете посмотреть исходные тексты заготовки в файлах shell.c, parseline.c, promptline.c и shell.h. Откомпилировав их, вы получите простой командный интерпретатор, способный выполнять программы в виде порожденных процессов, запускать фоновые процессы и перенаправлять ввод/вывод.)
НАПОЛОВИНУ
(6)
===
Если вы реализовали защиту от сигналов, модифицируйте ваш интерпретатор shell, так чтобы обеспечить следующие возможности для управления заданиями: SIGTSTP, посланный с клавиатуры (CTRL-Z по умолчанию), должен заставить основную программу перейти в фоновый режим и возобновить исполнение. PID переведенного на фон процесса будет выведен на stderr, и командный интерпретатор выдаст приглашение для следующей команды. 
@ Совет: сделайте каждый порожденный процесс лидером группы процессов и явным образом переводите его на первый план. Когда порожденный процесс первого плана завершается или останавливается, переводите на первый план интерпретатор.
(7)
===
Измените ваш командный интерпретатор так, чтобы он позволял создавать конвейеры. Если вы добавили управление заданиями в упражнениях Раздела 1, вы можете модифицировать программу так, чтобы все процессы в конвейере принадлежали к одной группе. Тогда, например, SIGINT мог бы прервать все процессы в конвейере первого плана.
НАПОЛОВИНУ (Не работает множественное перенаправление и завершение строк)
